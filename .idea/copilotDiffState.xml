<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.discoapp&quot;&gt;&#10;&#10;    &lt;!-- Permissions to record audio for the visualizer --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.DiscoApp&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.DiscoApp.NoActionBar&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.discoapp&quot;&gt;&#10;&#10;    &lt;!-- Permissions to record audio for the visualizer --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/AppTheme&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/AppTheme&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoEffect.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoEffect.kt" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.graphics.Color&#10;&#10;/**&#10; * Represents a disco lighting effect configuration.&#10; */&#10;data class DiscoEffect(&#10;    val colors: List&lt;Int&gt; = listOf(Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN),&#10;    val strobe: Boolean = false,&#10;    val fade: Boolean = false,&#10;    val duration: Long = 500L // duration in milliseconds for each color&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoFragment.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AdapterView&#10;import android.widget.ArrayAdapter&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentDiscoBinding&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that hosts the disco lighting experience. A [Spinner] allows the user to select&#10; * from a collection of generated [DiscoEffect]s. The selected effect is applied to the&#10; * [DiscoView] filling the remaining space. Effects are built algorithmically and vary in&#10; * palette, speed, fade transitions and strobing.&#10; */&#10;class DiscoFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDiscoBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private val effects by lazy { EffectRepository.createDiscoEffects(50) }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentDiscoBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Populate the spinner with effect names.&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, effectNames)&#10;        binding.spinnerDiscoEffects.adapter = adapter&#10;        // When the user selects an effect apply it to the DiscoView.&#10;        binding.spinnerDiscoEffects.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {&#10;                val effect = effects[position]&#10;                binding.discoView.setEffect(effect)&#10;            }&#10;            override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {&#10;                // No op.&#10;            }&#10;        }&#10;        // Initially apply the first effect.&#10;        if (effects.isNotEmpty()) {&#10;            binding.discoView.setEffect(effects[0])&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = DiscoFragment()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AdapterView&#10;import android.widget.ArrayAdapter&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentDiscoBinding&#10;import com.example.discoapp.model.DiscoEffect&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that hosts the disco lighting experience. A [Spinner] allows the user to select&#10; * from a collection of generated [DiscoEffect]s. The selected effect is applied to the&#10; * [DiscoView] filling the remaining space. Effects are built algorithmically and vary in&#10; * palette, speed, fade transitions and strobing.&#10; */&#10;class DiscoFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDiscoBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private val effects by lazy { EffectRepository.createDiscoEffects(50) }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentDiscoBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Populate the spinner with effect names.&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, effectNames)&#10;        binding.spinnerDiscoEffects.adapter = adapter&#10;        // When the user selects an effect apply it to the DiscoView.&#10;        binding.spinnerDiscoEffects.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {&#10;                val effect = effects[position]&#10;                binding.discoView.setEffect(effect)&#10;            }&#10;            override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {&#10;                // No op.&#10;            }&#10;        }&#10;        // Initially apply the first effect.&#10;        if (effects.isNotEmpty()) {&#10;            binding.discoView.setEffect(effects[0])&#10;        }&#10;    }&#10;&#10;    fun setEffectByIndex(index: Int) {&#10;        if (index in effects.indices) {&#10;            binding.spinnerDiscoEffects.setSelection(index)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = DiscoFragment()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoView.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.animation.ArgbEvaluator&#10;import android.animation.ValueAnimator&#10;import android.content.Context&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import androidx.core.animation.doOnEnd&#10;import com.example.discoapp.model.DiscoEffect&#10;&#10;/**&#10; * A custom view responsible for rendering a full‑screen disco lighting effect. The view cycles&#10; * through a list of colors defined in [DiscoEffect.colors] at a specified interval. When&#10; * [DiscoEffect.fade] is enabled, the transition between colors is animated using an&#10; * [ArgbEvaluator]; otherwise colors switch abruptly. If strobing is enabled, black frames&#10; * are inserted between colors to emulate a traditional strobe light.&#10; */&#10;class DiscoView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    /** A handler tied to the main thread for scheduling color changes when not animating. */&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var effect: DiscoEffect? = null&#10;    private var currentColorIndex: Int = 0&#10;    private var animator: ValueAnimator? = null&#10;    private var currentBackgroundColor: Int = Color.BLACK&#10;&#10;    /** Set a new disco lighting effect. This restarts the color cycle from the beginning. */&#10;    fun setEffect(effect: DiscoEffect) {&#10;        // Cancel any running animation or delayed callbacks.&#10;        animator?.cancel()&#10;        handler.removeCallbacksAndMessages(null)&#10;        // Apply the effect.&#10;        this.effect = effect&#10;        currentColorIndex = 0&#10;        // Kick off the first frame.&#10;        startNext()&#10;    }&#10;&#10;    /** Advance to the next color in the effect list, animating if necessary. */&#10;    private fun startNext() {&#10;        val eff = effect ?: return&#10;        var colors = eff.colors&#10;        // If strobe is enabled, interleave black frames between colors for a strobing effect.&#10;        if (eff.strobe) {&#10;            val strobeList = mutableListOf&lt;Int&gt;()&#10;            for (c in colors) {&#10;                strobeList.add(c)&#10;                strobeList.add(android.graphics.Color.BLACK)&#10;            }&#10;            colors = strobeList.toIntArray()&#10;        }&#10;        if (colors.isEmpty()) return&#10;        val nextColor = colors[currentColorIndex]&#10;        if (eff.fade) {&#10;            animator = android.animation.ValueAnimator.ofObject(android.animation.ArgbEvaluator(), currentBackgroundColor, nextColor).apply {&#10;                duration = eff.duration&#10;                addUpdateListener { animation -&gt;&#10;                    val color = animation.animatedValue as Int&#10;                    setBackgroundColor(color)&#10;                    currentBackgroundColor = color&#10;                }&#10;                androidx.core.animation.doOnEnd {&#10;                    currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                    startNext()&#10;                }&#10;                start()&#10;            }&#10;        } else {&#10;            setBackgroundColor(nextColor)&#10;            currentBackgroundColor = nextColor&#10;            handler.postDelayed({&#10;                currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                startNext()&#10;            }, eff.duration)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.animation.ArgbEvaluator&#10;import android.animation.ValueAnimator&#10;import android.content.Context&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import androidx.core.animation.doOnEnd&#10;import com.example.discoapp.model.DiscoEffect&#10;&#10;/**&#10; * A custom view responsible for rendering a full‑screen disco lighting effect. The view cycles&#10; * through a list of colors defined in [DiscoEffect.colors] at a specified interval. When&#10; * [DiscoEffect.fade] is enabled, the transition between colors is animated using an&#10; * [ArgbEvaluator]; otherwise colors switch abruptly. If strobing is enabled, black frames&#10; * are inserted between colors to emulate a traditional strobe light.&#10; */&#10;class DiscoView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    /** A handler tied to the main thread for scheduling color changes when not animating. */&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var effect: DiscoEffect? = null&#10;    private var currentColorIndex: Int = 0&#10;    private var animator: ValueAnimator? = null&#10;    private var currentBackgroundColor: Int = Color.BLACK&#10;&#10;    /** Set a new disco lighting effect. This restarts the color cycle from the beginning. */&#10;    fun setEffect(effect: DiscoEffect) {&#10;        // Cancel any running animation or delayed callbacks.&#10;        animator?.cancel()&#10;        handler.removeCallbacksAndMessages(null)&#10;        // Apply the effect.&#10;        this.effect = effect&#10;        currentColorIndex = 0&#10;        // Kick off the first frame.&#10;        startNext()&#10;    }&#10;&#10;    /** Advance to the next color in the effect list, animating if necessary. */&#10;    private fun startNext() {&#10;        val eff = effect ?: return&#10;        var colors = eff.colors&#10;        // If strobe is enabled, interleave black frames between colors for a strobing effect.&#10;        if (eff.strobe) {&#10;            val strobeList = mutableListOf&lt;Int&gt;()&#10;            for (c in colors) {&#10;                strobeList.add(c)&#10;                strobeList.add(android.graphics.Color.BLACK)&#10;            }&#10;            colors = strobeList.toIntArray()&#10;        }&#10;        if (colors.isEmpty()) return&#10;        val nextColor = colors[currentColorIndex]&#10;        if (eff.fade) {&#10;            animator = android.animation.ValueAnimator.ofObject(android.animation.ArgbEvaluator(), currentBackgroundColor, nextColor).apply {&#10;                duration = eff.duration&#10;                addUpdateListener { animation -&gt;&#10;                    val color = animation.animatedValue as Int&#10;                    setBackgroundColor(color)&#10;                    currentBackgroundColor = color&#10;                }&#10;                doOnEnd {&#10;                    currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                    startNext()&#10;                }&#10;                start()&#10;            }&#10;        } else {&#10;            setBackgroundColor(nextColor)&#10;            currentBackgroundColor = nextColor&#10;            handler.postDelayed({&#10;                currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                startNext()&#10;            }, eff.duration)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/EffectChipAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/EffectChipAdapter.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.view.LayoutInflater&#10;import android.view.ViewGroup&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.discoapp.databinding.ItemEffectChipBinding&#10;&#10;class EffectChipAdapter(&#10;    private val effects: List&lt;String&gt;,&#10;    private var selectedIndex: Int = 0,&#10;    private val onEffectSelected: (Int) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;EffectChipAdapter.ChipViewHolder&gt;() {&#10;&#10;    inner class ChipViewHolder(val binding: ItemEffectChipBinding) : RecyclerView.ViewHolder(binding.root)&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ChipViewHolder {&#10;        val binding = ItemEffectChipBinding.inflate(LayoutInflater.from(parent.context), parent, false)&#10;        return ChipViewHolder(binding)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ChipViewHolder, position: Int) {&#10;        val effectName = effects[position]&#10;        holder.binding.chipEffect.text = effectName&#10;        holder.binding.chipEffect.isChecked = position == selectedIndex&#10;        holder.binding.chipEffect.setOnClickListener {&#10;            val previousIndex = selectedIndex&#10;            selectedIndex = position&#10;            notifyItemChanged(previousIndex)&#10;            notifyItemChanged(selectedIndex)&#10;            onEffectSelected(position)&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = effects.size&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.view.LayoutInflater&#10;import android.view.ViewGroup&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.discoapp.databinding.ItemEffectChipBinding&#10;&#10;class EffectChipAdapter(&#10;    private val effects: List&lt;String&gt;,&#10;    private var selectedIndex: Int = 0,&#10;    private val onEffectSelected: (Int) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;EffectChipAdapter.ChipViewHolder&gt;() {&#10;&#10;    inner class ChipViewHolder(val binding: ItemEffectChipBinding) : RecyclerView.ViewHolder(binding.root)&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ChipViewHolder {&#10;        val binding = ItemEffectChipBinding.inflate(LayoutInflater.from(parent.context), parent, false)&#10;        return ChipViewHolder(binding)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ChipViewHolder, position: Int) {&#10;        val effectName = effects[position]&#10;        holder.binding.chipEffect.text = effectName&#10;        holder.binding.chipEffect.isChecked = position == selectedIndex&#10;        holder.binding.chipEffect.setOnClickListener {&#10;            if (selectedIndex != position) {&#10;                val previousIndex = selectedIndex&#10;                selectedIndex = position&#10;                notifyItemChanged(previousIndex)&#10;                notifyItemChanged(selectedIndex)&#10;                onEffectSelected(position)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = effects.size&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/MainActivity.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.os.Bundle&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.viewpager2.widget.ViewPager2&#10;import com.example.discoapp.databinding.ActivityMainBinding&#10;import com.google.android.material.tabs.TabLayoutMediator&#10;&#10;/**&#10; * The main activity hosts a [ViewPager2] with two fragments: one for disco lighting and one for&#10; * audio visualization. A tab layout in the app bar allows the user to switch between modes&#10; * seamlessly. The page titles and icons are defined in [SectionsPagerAdapter].&#10; */&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setSupportActionBar(binding.toolbar)&#10;&#10;        // Set up the ViewPager with the sections adapter.&#10;        val sectionsPagerAdapter = SectionsPagerAdapter(this)&#10;        binding.viewPager.adapter = sectionsPagerAdapter&#10;&#10;        // Attach the TabLayout to the ViewPager and set the titles/icons.&#10;        val tabTitles = listOf(&#10;            getString(R.string.disco_mode),&#10;            getString(R.string.visualizer_mode)&#10;        )&#10;        TabLayoutMediator(binding.tabs, binding.viewPager) { tab, position -&gt;&#10;            tab.text = tabTitles[position]&#10;        }.attach()&#10;    }&#10;&#10;    override fun onStart() {&#10;        super.onStart()&#10;        // Setup menu button to show/hide the box of 50 tiny buttons&#10;        val menuButton = binding.menuButton&#10;        val buttonBoxScroll = binding.buttonBoxScroll&#10;        val buttonBox = binding.buttonBox&#10;&#10;        // Only add buttons once&#10;        if (buttonBox.childCount == 0) {&#10;            for (i in 1..50) {&#10;                val btn = android.widget.Button(this).apply {&#10;                    text = i.toString()&#10;                    textSize = 10f&#10;                    minWidth = 0&#10;                    minHeight = 0&#10;                    setPadding(4, 4, 4, 4)&#10;                    layoutParams = android.widget.GridLayout.LayoutParams().apply {&#10;                        width = 0&#10;                        height = android.widget.GridLayout.LayoutParams.WRAP_CONTENT&#10;                        columnSpec = android.widget.GridLayout.spec(android.widget.GridLayout.UNDEFINED, 1f)&#10;                        setMargins(2, 2, 2, 2)&#10;                    }&#10;                }&#10;                buttonBox.addView(btn)&#10;            }&#10;        }&#10;&#10;        menuButton.setOnClickListener {&#10;            buttonBoxScroll.visibility = if (buttonBoxScroll.visibility == android.view.View.VISIBLE) android.view.View.GONE else android.view.View.VISIBLE&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.os.Bundle&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.viewpager2.widget.ViewPager2&#10;import com.example.discoapp.databinding.ActivityMainBinding&#10;import com.google.android.material.tabs.TabLayoutMediator&#10;&#10;/**&#10; * The main activity hosts a [ViewPager2] with two fragments: one for disco lighting and one for&#10; * audio visualization. A tab layout in the app bar allows the user to switch between modes&#10; * seamlessly. The page titles and icons are defined in [SectionsPagerAdapter].&#10; */&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setSupportActionBar(binding.toolbar)&#10;&#10;        // Set up the ViewPager with the sections adapter.&#10;        val sectionsPagerAdapter = SectionsPagerAdapter(this)&#10;        binding.viewPager.adapter = sectionsPagerAdapter&#10;&#10;        // Attach the TabLayout to the ViewPager and set the titles/icons.&#10;        val tabTitles = listOf(&#10;            getString(R.string.disco_mode),&#10;            getString(R.string.visualizer_mode)&#10;        )&#10;        TabLayoutMediator(binding.tabs, binding.viewPager) { tab, position -&gt;&#10;            tab.text = tabTitles[position]&#10;        }.attach()&#10;    }&#10;&#10;    override fun onStart() {&#10;        super.onStart()&#10;        // Setup menu button to show/hide the box of 50 tiny buttons&#10;        val menuButton = binding.menuButton&#10;        val buttonBoxScroll = binding.buttonBoxScroll&#10;        val buttonBox = binding.buttonBox&#10;&#10;        // Only add buttons once&#10;        if (buttonBox.childCount == 0) {&#10;            for (i in 1..50) {&#10;                val btn = android.widget.Button(this).apply {&#10;                    text = i.toString()&#10;                    textSize = 10f&#10;                    minWidth = 0&#10;                    minHeight = 0&#10;                    setPadding(4, 4, 4, 4)&#10;                    layoutParams = android.widget.GridLayout.LayoutParams().apply {&#10;                        width = 0&#10;                        height = android.widget.GridLayout.LayoutParams.WRAP_CONTENT&#10;                        columnSpec = android.widget.GridLayout.spec(android.widget.GridLayout.UNDEFINED, 1f)&#10;                        setMargins(2, 2, 2, 2)&#10;                    }&#10;                    setOnClickListener {&#10;                        val effectIndex = i - 1&#10;                        val currentItem = binding.viewPager.currentItem&#10;                        val fragment = supportFragmentManager.findFragmentByTag(&quot;f$currentItem&quot;)&#10;                        when (fragment) {&#10;                            is DiscoFragment -&gt; fragment.setEffectByIndex(effectIndex)&#10;                            is VisualizerFragment -&gt; fragment.setEffectByIndex(effectIndex)&#10;                        }&#10;                    }&#10;                }&#10;                buttonBox.addView(btn)&#10;            }&#10;        }&#10;&#10;        menuButton.setOnClickListener {&#10;            buttonBoxScroll.visibility = if (buttonBoxScroll.visibility == android.view.View.VISIBLE) android.view.View.GONE else android.view.View.VISIBLE&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerFragment.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentVisualizerBinding&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that renders audio responsive visuals. It requests the RECORD_AUDIO permission on&#10; * demand and, once granted, allows the user to choose between a variety of visualizer effects.&#10; */&#10;class VisualizerFragment : Fragment() {&#10;&#10;    private var _binding: FragmentVisualizerBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val effects by lazy { EffectRepository.createVisualizerEffects(51) }&#10;    // Launcher for requesting audio recording permission.&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted; apply the selected effect.&#10;            applyEffect(selectedEffectIndex)&#10;        } else {&#10;            // Permission denied; inform the user.&#10;            binding.visualizerView.visibility = View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    private var selectedEffectIndex: Int = 0&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentVisualizerBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Initially hide the view until permission is granted.&#10;        binding.visualizerView.visibility = View.INVISIBLE&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        applyEffect(selectedEffectIndex)&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        binding.visualizerView.stop()&#10;    }&#10;&#10;    /**&#10;     * Applies the visualizer effect at the given index after ensuring the RECORD_AUDIO permission&#10;     * has been granted. If the permission is not available, it requests it.&#10;     */&#10;    private fun applyEffect(index: Int) {&#10;        val context = context ?: return&#10;        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {&#10;            // Permission has already been granted. Show the visualizer and apply the effect.&#10;            binding.visualizerView.visibility = View.VISIBLE&#10;            binding.visualizerView.setEffect(effects[index])&#10;            binding.visualizerView.start()&#10;        } else {&#10;            // Request permission. The result is handled in requestPermissionLauncher.&#10;            requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = VisualizerFragment()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.discoapp.EffectChipAdapter&#10;import com.example.discoapp.databinding.FragmentVisualizerBinding&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that renders audio responsive visuals. It requests the RECORD_AUDIO permission on&#10; * demand and, once granted, allows the user to choose between a variety of visualizer effects.&#10; */&#10;class VisualizerFragment : Fragment() {&#10;&#10;    private var _binding: FragmentVisualizerBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val effects by lazy { EffectRepository.createVisualizerEffects(51) }&#10;    // Launcher for requesting audio recording permission.&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted; apply the selected effect.&#10;            applyEffect(selectedEffectIndex)&#10;        } else {&#10;            // Permission denied; inform the user.&#10;            binding.visualizerView.visibility = View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    private var selectedEffectIndex: Int = 0&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentVisualizerBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Set up horizontal chip selector for effects&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = EffectChipAdapter(effectNames, selectedEffectIndex) { index -&gt;&#10;            selectedEffectIndex = index&#10;            applyEffect(index)&#10;        }&#10;        binding.recyclerVisualizerEffects.layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.HORIZONTAL, false)&#10;        binding.recyclerVisualizerEffects.adapter = adapter&#10;        // Initially hide the view until permission is granted.&#10;        binding.visualizerView.visibility = View.INVISIBLE&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        applyEffect(selectedEffectIndex)&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        binding.visualizerView.stop()&#10;    }&#10;&#10;    /**&#10;     * Applies the visualizer effect at the given index after ensuring the RECORD_AUDIO permission&#10;     * has been granted. If the permission is not available, it requests it.&#10;     */&#10;    private fun applyEffect(index: Int) {&#10;        val context = context ?: return&#10;        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {&#10;            // Permission has already been granted. Show the visualizer and apply the effect.&#10;            binding.visualizerView.visibility = View.VISIBLE&#10;            binding.visualizerView.setEffect(effects[index])&#10;            binding.visualizerView.start()&#10;        } else {&#10;            // Request permission. The result is handled in requestPermissionLauncher.&#10;            requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Public method to set the effect by index, to be called from MainActivity.&#10;     */&#10;    fun setEffectByIndex(index: Int) {&#10;        if (index in effects.indices) {&#10;            selectedEffectIndex = index&#10;            applyEffect(index)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = VisualizerFragment()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerView.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.graphics.Canvas&#10;import android.graphics.LinearGradient&#10;import android.graphics.Paint&#10;import android.graphics.Path&#10;import android.graphics.Shader&#10;import android.media.AudioFormat&#10;import android.media.AudioRecord&#10;import android.media.MediaRecorder&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import com.example.discoapp.model.VisualizerEffect&#10;import com.example.discoapp.model.VisualizerShape&#10;import kotlin.math.abs&#10;import kotlin.math.cos&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;/**&#10; * A custom view that visualizes audio data captured from the device's microphone. The view&#10; * supports three distinct shapes—bars, radial spokes and a waveform—whose appearance and&#10; * behaviour are controlled through instances of [VisualizerEffect].&#10; *&#10; * The view manages an underlying [AudioRecord] instance to capture raw audio data. When a new&#10; * effect is set via [setEffect], the view resets its renderer and applies the new colours,&#10; * bar count and amplitude multiplier. When the view is detached from the window it releases&#10; * the audio resources to conserve power.&#10; */&#10;class VisualizerView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    private var audioRecord: AudioRecord? = null&#10;    private var waveform: ByteArray = ByteArray(0)&#10;    private var effect: VisualizerEffect? = null&#10;    private val paint = Paint().apply {&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    private var gradient: LinearGradient? = null&#10;    private var isCapturing = false&#10;&#10;    /**&#10;     * Assign an effect to this view and initialize audio capture if necessary. This method&#10;     * should be called after the RECORD_AUDIO permission has been granted. Setting a new effect&#10;     * replaces any existing effect and resets the colour gradient.&#10;     */&#10;    fun setEffect(effect: VisualizerEffect) {&#10;        this.effect = effect&#10;        gradient = null&#10;        invalidate()&#10;    }&#10;&#10;    /**&#10;     * Set up and start the [AudioRecord] instance to capture audio from the microphone. Audio&#10;     * data is read in a background thread to avoid blocking the UI.&#10;     */&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun start() {&#10;        if (isCapturing) return&#10;        try {&#10;            val sampleRate = 44100&#10;            val channelConfig = AudioFormat.CHANNEL_IN_MONO&#10;            val audioFormat = AudioFormat.ENCODING_PCM_8BIT&#10;            val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat).coerceAtLeast(1024)&#10;&#10;            audioRecord = AudioRecord(&#10;                MediaRecorder.AudioSource.MIC,&#10;                sampleRate,&#10;                channelConfig,&#10;                audioFormat,&#10;                bufferSize&#10;            )&#10;&#10;            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {&#10;                audioRecord = null&#10;                return&#10;            }&#10;&#10;            waveform = ByteArray(bufferSize)&#10;            audioRecord?.startRecording()&#10;&#10;            isCapturing = true&#10;            Thread {&#10;                while (isCapturing) {&#10;                    audioRecord?.read(waveform, 0, waveform.size)&#10;                    postInvalidate()&#10;                }&#10;                audioRecord?.stop()&#10;                audioRecord?.release()&#10;                audioRecord = null&#10;            }.start()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    fun stop() {&#10;        isCapturing = false&#10;    }&#10;&#10;    override fun onDetachedFromWindow() {&#10;        super.onDetachedFromWindow()&#10;        stop()&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        rebuildGradient()&#10;    }&#10;&#10;    /** Recreate a linear gradient across the width of the view using the current effect colours. */&#10;    private fun rebuildGradient() {&#10;        val eff = effect ?: return&#10;        if (eff.colors.size &gt; 1) {&#10;            val positions = FloatArray(eff.colors.size) { i -&gt; i.toFloat() / (eff.colors.size - 1) }&#10;            gradient = LinearGradient(&#10;                0f, 0f, width.toFloat(), 0f,&#10;                eff.colors, positions, Shader.TileMode.CLAMP&#10;            )&#10;        } else {&#10;            gradient = null&#10;        }&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        val eff = effect ?: return&#10;        if (waveform.isEmpty() || !isCapturing) return&#10;        when (eff.shape) {&#10;            VisualizerShape.BARS -&gt; drawBars(canvas, eff)&#10;            VisualizerShape.RADIAL -&gt; drawRadial(canvas, eff)&#10;            VisualizerShape.WAVE -&gt; drawWave(canvas, eff)&#10;        }&#10;    }&#10;&#10;    /** Draws a vertical bar graph where each bar height corresponds to the amplitude of a sample. */&#10;    private fun drawBars(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        if (barCount &lt;= 0) return&#10;        val barWidth = width.toFloat() / barCount&#10;        val centerY = height.toFloat()&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * centerY * eff.amplitudeMultiplier&#10;            val left = i * barWidth&#10;            val right = left + barWidth * 0.8f&#10;            val top = centerY - amplitude&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawRect(left, top, right, centerY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws radial spokes emanating from the center of the view based on amplitude. */&#10;    private fun drawRadial(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        val centerX = width / 2f&#10;        val centerY = height / 2f&#10;        val maxRadius = min(width, height) / 2f&#10;        paint.strokeWidth = 4f&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * maxRadius * eff.amplitudeMultiplier&#10;            val angle = (2.0 * Math.PI * i / barCount).toFloat()&#10;            val endX = centerX + amplitude * cos(angle)&#10;            val endY = centerY + amplitude * sin(angle)&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawLine(centerX, centerY, endX, endY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws a continuous waveform across the width of the view. */&#10;    private fun drawWave(canvas: Canvas, eff: VisualizerEffect) {&#10;        val dataLength = waveform.size&#10;        if (dataLength == 0) return&#10;        val path = Path()&#10;        val halfHeight = height / 2f&#10;        val step = width.toFloat() / dataLength&#10;        for (i in 0 until dataLength) {&#10;            val value = waveform[i].toInt() and 0xFF&#10;            val amplitude = (value - 128) / 128f * halfHeight * eff.amplitudeMultiplier&#10;            val x = i * step&#10;            val y = halfHeight + amplitude&#10;            if (i == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;        paint.strokeWidth = 4f&#10;        paint.style = Paint.Style.STROKE&#10;        if (gradient != null) {&#10;            paint.shader = gradient&#10;        } else {&#10;            paint.color = eff.colors.firstOrNull() ?: 0xFFFFFFFF.toInt()&#10;            paint.shader = null&#10;        }&#10;        canvas.drawPath(path, paint)&#10;        // Reset style for next draw call.&#10;        paint.style = Paint.Style.FILL&#10;        paint.shader = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.graphics.Canvas&#10;import android.graphics.LinearGradient&#10;import android.graphics.Paint&#10;import android.graphics.Path&#10;import android.graphics.Shader&#10;import android.media.AudioFormat&#10;import android.media.AudioRecord&#10;import android.media.MediaRecorder&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import com.example.discoapp.model.VisualizerEffect&#10;import com.example.discoapp.model.VisualizerShape&#10;import kotlin.math.abs&#10;import kotlin.math.cos&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;/**&#10; * A custom view that visualizes audio data captured from the device's microphone. The view&#10; * supports three distinct shapes—bars, radial spokes and a waveform—whose appearance and&#10; * behaviour are controlled through instances of [VisualizerEffect].&#10; *&#10; * The view manages an underlying [AudioRecord] instance to capture raw audio data. When a new&#10; * effect is set via [setEffect], the view resets its renderer and applies the new colours,&#10; * bar count and amplitude multiplier. When the view is detached from the window it releases&#10; * the audio resources to conserve power.&#10; */&#10;class VisualizerView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    private var audioRecord: AudioRecord? = null&#10;    private var waveform: ByteArray = ByteArray(0)&#10;    private var effect: VisualizerEffect? = null&#10;    private val paint = Paint().apply {&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    private var gradient: LinearGradient? = null&#10;    private var captureThread: Thread? = null&#10;    private var isCapturing = false&#10;&#10;    /**&#10;     * Assign an effect to this view and initialize audio capture if necessary. This method&#10;     * should be called after the RECORD_AUDIO permission has been granted. Setting a new effect&#10;     * replaces any existing effect and resets the colour gradient.&#10;     */&#10;    fun setEffect(effect: VisualizerEffect) {&#10;        this.effect = effect&#10;        gradient = null&#10;        invalidate()&#10;    }&#10;&#10;    /**&#10;     * Set up and start the [AudioRecord] instance to capture audio from the microphone. Audio&#10;     * data is read in a background thread to avoid blocking the UI.&#10;     */&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun start() {&#10;        if (isCapturing) return&#10;        try {&#10;            val sampleRate = 44100&#10;            val channelConfig = AudioFormat.CHANNEL_IN_MONO&#10;            val audioFormat = AudioFormat.ENCODING_PCM_8BIT&#10;            val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat).coerceAtLeast(1024)&#10;&#10;            audioRecord = AudioRecord(&#10;                MediaRecorder.AudioSource.MIC,&#10;                sampleRate,&#10;                channelConfig,&#10;                audioFormat,&#10;                bufferSize&#10;            )&#10;&#10;            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {&#10;                audioRecord = null&#10;                return&#10;            }&#10;&#10;            waveform = ByteArray(bufferSize)&#10;            audioRecord?.startRecording()&#10;&#10;            isCapturing = true&#10;            captureThread = Thread {&#10;                while (isCapturing) {&#10;                    audioRecord?.read(waveform, 0, waveform.size)&#10;                    postInvalidate()&#10;                }&#10;            }&#10;            captureThread?.start()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    fun stop() {&#10;        if (!isCapturing) return&#10;        isCapturing = false&#10;        try {&#10;            captureThread?.join(100)&#10;        } catch (e: InterruptedException) {&#10;            Thread.currentThread().interrupt()&#10;        }&#10;        captureThread = null&#10;        if (audioRecord?.recordingState == AudioRecord.RECORDSTATE_RECORDING) {&#10;            audioRecord?.stop()&#10;        }&#10;        audioRecord?.release()&#10;        audioRecord = null&#10;    }&#10;&#10;    override fun onDetachedFromWindow() {&#10;        super.onDetachedFromWindow()&#10;        stop()&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        rebuildGradient()&#10;    }&#10;&#10;    /** Recreate a linear gradient across the width of the view using the current effect colours. */&#10;    private fun rebuildGradient() {&#10;        val eff = effect ?: return&#10;        if (eff.colors.size &gt; 1) {&#10;            val positions = FloatArray(eff.colors.size) { i -&gt; i.toFloat() / (eff.colors.size - 1) }&#10;            gradient = LinearGradient(&#10;                0f, 0f, width.toFloat(), 0f,&#10;                eff.colors, positions, Shader.TileMode.CLAMP&#10;            )&#10;        } else {&#10;            gradient = null&#10;        }&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        val eff = effect ?: return&#10;        if (waveform.isEmpty() || !isCapturing) return&#10;        when (eff.shape) {&#10;            VisualizerShape.BARS -&gt; drawBars(canvas, eff)&#10;            VisualizerShape.RADIAL -&gt; drawRadial(canvas, eff)&#10;            VisualizerShape.WAVE -&gt; drawWave(canvas, eff)&#10;        }&#10;    }&#10;&#10;    /** Draws a vertical bar graph where each bar height corresponds to the amplitude of a sample. */&#10;    private fun drawBars(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        if (barCount &lt;= 0) return&#10;        val barWidth = width.toFloat() / barCount&#10;        val centerY = height.toFloat()&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * centerY * eff.amplitudeMultiplier&#10;            val left = i * barWidth&#10;            val right = left + barWidth * 0.8f&#10;            val top = centerY - amplitude&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawRect(left, top, right, centerY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws radial spokes emanating from the center of the view based on amplitude. */&#10;    private fun drawRadial(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        val centerX = width / 2f&#10;        val centerY = height / 2f&#10;        val maxRadius = min(width, height) / 2f&#10;        paint.strokeWidth = 4f&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * maxRadius * eff.amplitudeMultiplier&#10;            val angle = (2.0 * Math.PI * i / barCount).toFloat()&#10;            val endX = centerX + amplitude * cos(angle)&#10;            val endY = centerY + amplitude * sin(angle)&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawLine(centerX, centerY, endX, endY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws a continuous waveform across the width of the view. */&#10;    private fun drawWave(canvas: Canvas, eff: VisualizerEffect) {&#10;        val dataLength = waveform.size&#10;        if (dataLength == 0) return&#10;        val path = Path()&#10;        val halfHeight = height / 2f&#10;        val step = width.toFloat() / dataLength&#10;        for (i in 0 until dataLength) {&#10;            val value = waveform[i].toInt() and 0xFF&#10;            val amplitude = (value - 128) / 128f * halfHeight * eff.amplitudeMultiplier&#10;            val x = i * step&#10;            val y = halfHeight + amplitude&#10;            if (i == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;        paint.strokeWidth = 4f&#10;        paint.style = Paint.Style.STROKE&#10;        if (gradient != null) {&#10;            paint.shader = gradient&#10;        } else {&#10;            paint.color = eff.colors.firstOrNull() ?: 0xFFFFFFFF.toInt()&#10;            paint.shader = null&#10;        }&#10;        canvas.drawPath(path, paint)&#10;        // Reset style for next draw call.&#10;        paint.style = Paint.Style.FILL&#10;        paint.shader = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/DiscoEffect.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/DiscoEffect.kt" />
              <option name="originalContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;&#10;/**&#10; * Represents a disco lighting effect configuration.&#10; */&#10;data class DiscoEffect(&#10;    val name: String = &quot;Default&quot;,&#10;    val colors: List&lt;Int&gt; = listOf(Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN),&#10;    val duration: Long = 500L, // duration in milliseconds for each color&#10;    val fade: Boolean = false,&#10;    val strobe: Boolean = false&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;&#10;/**&#10; * Represents a disco lighting effect configuration.&#10; */&#10;data class DiscoEffect(&#10;    val name: String = &quot;Default&quot;,&#10;    val colors: List&lt;Int&gt; = listOf(Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN),&#10;    val duration: Long = 500L, // duration in milliseconds for each color&#10;    val fade: Boolean = false,&#10;    val strobe: Boolean = false&#10;)&#10;&#10;// Duplicate DiscoEffect removed. Use the one in EffectModels.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/EffectRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/EffectRepository.kt" />
              <option name="originalContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;import java.util.Random&#10;&#10;/**&#10; * Factory methods for generating a collection of disco and visualizer effects. To keep the&#10; * application lightweight and to avoid hand‑crafting dozens of variations, this repository&#10; * algorithmically derives different combinations of color palettes, animation speeds, shapes&#10; * and amplitude multipliers based on the index of the requested effect. This makes it easy&#10; * to provide a large number of unique visual experiences without repeating code.&#10; */&#10;object EffectRepository {&#10;&#10;    /** A set of base color palettes used to construct more complex effects. */&#10;    private val palettes: List&lt;IntArray&gt; = listOf(&#10;        intArrayOf(Color.parseColor(&quot;#ff1744&quot;), Color.parseColor(&quot;#d500f9&quot;), Color.parseColor(&quot;#2979ff&quot;), Color.parseColor(&quot;#00e5ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff6f00&quot;), Color.parseColor(&quot;#fdd835&quot;), Color.parseColor(&quot;#64dd17&quot;), Color.parseColor(&quot;#1de9b6&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ab47bc&quot;), Color.parseColor(&quot;#ef5350&quot;), Color.parseColor(&quot;#ffa726&quot;), Color.parseColor(&quot;#66bb6a&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#00b0ff&quot;), Color.parseColor(&quot;#651fff&quot;), Color.parseColor(&quot;#c51162&quot;), Color.parseColor(&quot;#ff4081&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#4caf50&quot;), Color.parseColor(&quot;#009688&quot;), Color.parseColor(&quot;#00bcd4&quot;), Color.parseColor(&quot;#3f51b5&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff8a80&quot;), Color.parseColor(&quot;#ff80ab&quot;), Color.parseColor(&quot;#ea80fc&quot;), Color.parseColor(&quot;#b388ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ffd180&quot;), Color.parseColor(&quot;#ffe57f&quot;), Color.parseColor(&quot;#dcedc8&quot;), Color.parseColor(&quot;#b2ebf2&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#81d4fa&quot;), Color.parseColor(&quot;#80cbc4&quot;), Color.parseColor(&quot;#c5e1a5&quot;), Color.parseColor(&quot;#f8bbd0&quot;))&#10;    )&#10;&#10;    /**&#10;     * Create a list of disco effects. Each effect's parameters are derived from its index&#10;     * to produce a variety of rhythms, fades and strobing behaviours. The number of effects&#10;     * generated is determined by [count].&#10;     */&#10;    fun createDiscoEffects(count: Int): List&lt;DiscoEffect&gt; {&#10;        val effects = mutableListOf&lt;DiscoEffect&gt;()&#10;        val random = Random(System.currentTimeMillis())&#10;        for (i in 0 until count) {&#10;            val name = &quot;Effect ${i + 1}&quot;&#10;            val duration = random.nextLong(250, 1000)&#10;            val fade = random.nextBoolean()&#10;            val strobe = random.nextBoolean()&#10;            val palette = createPalette(random)&#10;            effects += DiscoEffect(name, palette, duration, fade, strobe)&#10;        }&#10;        return effects&#10;    }&#10;&#10;    /**&#10;     * Create a list of visualizer effects. Each effect's attributes are derived from its index&#10;     * to vary bar counts, shapes, colors and amplitude scaling. The number of effects generated&#10;     * is determined by [count].&#10;     */&#10;    fun createVisualizerEffects(count: Int): List&lt;VisualizerEffect&gt; {&#10;        val effects = mutableListOf&lt;VisualizerEffect&gt;()&#10;        for (i in 0 until count) {&#10;            val palette = palettes[(i + 2) % palettes.size]&#10;            // Determine bar count: 16, 32, 48, 64 depending on index.&#10;            val barCount = when (i % 4) {&#10;                0 -&gt; 16&#10;                1 -&gt; 32&#10;                2 -&gt; 48&#10;                else -&gt; 64&#10;            }&#10;            // Alternate shape between bars, radial and wave.&#10;            val shape = when (i % 3) {&#10;                0 -&gt; VisualizerShape.BARS&#10;                1 -&gt; VisualizerShape.RADIAL&#10;                else -&gt; VisualizerShape.WAVE&#10;            }&#10;            // Determine amplitude multiplier between 2.0f and 5.0f.&#10;            val amplitudeMultiplier = 2.0f + (i % 4) * 0.75f&#10;            val name = &quot;Visualizer #${i + 1}&quot;&#10;            effects += VisualizerEffect(name, barCount, shape, palette, amplitudeMultiplier)&#10;        }&#10;        return effects&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;import java.util.Random&#10;&#10;/**&#10; * Factory methods for generating a collection of disco and visualizer effects. To keep the&#10; * application lightweight and to avoid hand‑crafting dozens of variations, this repository&#10; * algorithmically derives different combinations of color palettes, animation speeds, shapes&#10; * and amplitude multipliers based on the index of the requested effect. This makes it easy&#10; * to provide a large number of unique visual experiences without repeating code.&#10; */&#10;object EffectRepository {&#10;&#10;    /** A set of base color palettes used to construct more complex effects. */&#10;    private val palettes: List&lt;IntArray&gt; = listOf(&#10;        intArrayOf(Color.parseColor(&quot;#ff1744&quot;), Color.parseColor(&quot;#d500f9&quot;), Color.parseColor(&quot;#2979ff&quot;), Color.parseColor(&quot;#00e5ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff6f00&quot;), Color.parseColor(&quot;#fdd835&quot;), Color.parseColor(&quot;#64dd17&quot;), Color.parseColor(&quot;#1de9b6&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ab47bc&quot;), Color.parseColor(&quot;#ef5350&quot;), Color.parseColor(&quot;#ffa726&quot;), Color.parseColor(&quot;#66bb6a&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#00b0ff&quot;), Color.parseColor(&quot;#651fff&quot;), Color.parseColor(&quot;#c51162&quot;), Color.parseColor(&quot;#ff4081&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#4caf50&quot;), Color.parseColor(&quot;#009688&quot;), Color.parseColor(&quot;#00bcd4&quot;), Color.parseColor(&quot;#3f51b5&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff8a80&quot;), Color.parseColor(&quot;#ff80ab&quot;), Color.parseColor(&quot;#ea80fc&quot;), Color.parseColor(&quot;#b388ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ffd180&quot;), Color.parseColor(&quot;#ffe57f&quot;), Color.parseColor(&quot;#dcedc8&quot;), Color.parseColor(&quot;#b2ebf2&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#81d4fa&quot;), Color.parseColor(&quot;#80cbc4&quot;), Color.parseColor(&quot;#c5e1a5&quot;), Color.parseColor(&quot;#f8bbd0&quot;))&#10;    )&#10;&#10;    /**&#10;     * Create a list of disco effects. Each effect's parameters are derived from its index&#10;     * to produce a variety of rhythms, fades and strobing behaviours. The number of effects&#10;     * generated is determined by [count].&#10;     */&#10;    fun createDiscoEffects(count: Int): List&lt;DiscoEffect&gt; {&#10;        val effects = mutableListOf&lt;DiscoEffect&gt;()&#10;        val random = Random(System.currentTimeMillis())&#10;        for (i in 0 until count) {&#10;            val name = &quot;Effect ${i + 1}&quot;&#10;            val duration = (250 + random.nextInt(750)).toLong()&#10;            val fade = random.nextBoolean()&#10;            val strobe = random.nextBoolean()&#10;            val palette = createPalette(random)&#10;            effects += DiscoEffect(name, palette, duration, fade, strobe)&#10;        }&#10;        return effects&#10;    }&#10;&#10;    /**&#10;     * Create a list of visualizer effects. Each effect's attributes are derived from its index&#10;     * to vary bar counts, shapes, colors and amplitude scaling. The number of effects generated&#10;     * is determined by [count].&#10;     */&#10;    fun createVisualizerEffects(count: Int): List&lt;VisualizerEffect&gt; {&#10;        val effects = mutableListOf&lt;VisualizerEffect&gt;()&#10;        for (i in 0 until count) {&#10;            val palette = palettes[(i + 2) % palettes.size]&#10;            // Determine bar count: 16, 32, 48, 64 depending on index.&#10;            val barCount = when (i % 4) {&#10;                0 -&gt; 16&#10;                1 -&gt; 32&#10;                2 -&gt; 48&#10;                else -&gt; 64&#10;            }&#10;            // Alternate shape between bars, radial and wave.&#10;            val shape = when (i % 3) {&#10;                0 -&gt; VisualizerShape.BARS&#10;                1 -&gt; VisualizerShape.RADIAL&#10;                else -&gt; VisualizerShape.WAVE&#10;            }&#10;            // Determine amplitude multiplier between 2.0f and 5.0f.&#10;            val amplitudeMultiplier = 2.0f + (i % 4) * 0.75f&#10;            val name = &quot;Visualizer #${i + 1}&quot;&#10;            effects += VisualizerEffect(name, barCount, shape, palette, amplitudeMultiplier)&#10;        }&#10;        return effects&#10;    }&#10;&#10;    private fun createPalette(random: Random): IntArray {&#10;        return palettes[random.nextInt(palettes.size)]&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.MainActivity&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:theme=&quot;@style/ThemeOverlay.Material3.Dark.ActionBar&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:title=&quot;@string/app_name&quot;&#10;            app:titleTextColor=&quot;@color/colorOnSurface&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.tabs.TabLayout&#10;            android:id=&quot;@+id/tabs&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:tabIndicatorColor=&quot;@color/colorSecondary&quot;&#10;            app:tabTextColor=&quot;@color/colorOnSurface&quot;&#10;            app:tabSelectedTextColor=&quot;@color/colorSecondary&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.viewpager2.widget.ViewPager2&#10;        android:id=&quot;@+id/viewPager&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;&#10;&#10;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.MainActivity&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:theme=&quot;@style/ThemeOverlay.Material3.Dark.ActionBar&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:title=&quot;@string/app_name&quot;&#10;            app:titleTextColor=&quot;@color/colorOnSurface&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.tabs.TabLayout&#10;            android:id=&quot;@+id/tabs&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:tabIndicatorColor=&quot;@color/colorSecondary&quot;&#10;            app:tabTextColor=&quot;@color/colorOnSurface&quot;&#10;            app:tabSelectedTextColor=&quot;@color/colorSecondary&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.viewpager2.widget.ViewPager2&#10;        android:id=&quot;@+id/viewPager&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;&#10;&#10;    &lt;!-- Menu Button --&gt;&#10;    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton&#10;        android:id=&quot;@+id/menuButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;bottom|end&quot;&#10;        android:layout_margin=&quot;24dp&quot;&#10;        android:contentDescription=&quot;Menu&quot;&#10;        app:srcCompat=&quot;@android:drawable/ic_menu_more&quot; /&gt;&#10;&#10;    &lt;!-- Box with 50 tiny buttons (initially hidden) --&gt;&#10;    &lt;ScrollView&#10;        android:id=&quot;@+id/buttonBoxScroll&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;300dp&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        android:background=&quot;#DDFFFFFF&quot;&#10;        android:elevation=&quot;8dp&quot;&gt;&#10;        &lt;GridLayout&#10;            android:id=&quot;@+id/buttonBox&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:columnCount=&quot;10&quot;&#10;            android:padding=&quot;8dp&quot; /&gt;&#10;    &lt;/ScrollView&gt;&#10;&#10;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_visualizer.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_visualizer.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.VisualizerFragment&quot;&gt;&#10;&#10;    &lt;!-- Spinner to choose between different visualizer styles. --&gt;&#10;    &lt;Spinner&#10;        android:id=&quot;@+id/spinnerVisualizerEffects&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;16dp&quot;&#10;        android:layout_marginEnd=&quot;16dp&quot;&#10;        android:background=&quot;@drawable/spinner_background&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Custom view that draws audio responsive visuals. --&gt;&#10;    &lt;com.example.discoapp.VisualizerView&#10;        android:id=&quot;@+id/visualizerView&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/spinnerVisualizerEffects&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    tools:context=&quot;.VisualizerFragment&quot;&gt;&#10;&#10;    &lt;!-- Horizontal RecyclerView to choose between different visualizer styles. --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/recyclerVisualizerEffects&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&#10;        android:paddingTop=&quot;8dp&quot;&#10;        android:paddingBottom=&quot;8dp&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        tools:listitem=&quot;@layout/item_effect_chip&quot; /&gt;&#10;&#10;    &lt;!-- Custom view that draws audio responsive visuals. --&gt;&#10;    &lt;com.example.discoapp.VisualizerView&#10;        android:id=&quot;@+id/visualizerView&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/recyclerVisualizerEffects&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_effect_chip.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_effect_chip.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;com.google.android.material.chip.Chip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    style=&quot;@style/Widget.MaterialComponents.Chip.Choice&quot;&#10;    android:id=&quot;@+id/chipEffect&quot;&#10;    android:layout_width=&quot;wrap_content&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:layout_margin=&quot;4dp&quot;&#10;    android:text=&quot;Effect&quot;&#10;    android:textAppearance=&quot;@style/TextAppearance.MaterialComponents.Body2&quot;&#10;    android:checkable=&quot;true&quot;&#10;    android:clickable=&quot;true&quot;&#10;    android:focusable=&quot;true&quot;&#10;    android:ellipsize=&quot;end&quot;&#10;    android:maxLines=&quot;1&quot;&#10;    android:minWidth=&quot;48dp&quot;&#10;    android:minHeight=&quot;32dp&quot;&#10;    android:textColor=&quot;?android:attr/textColorPrimary&quot;&#10;    /&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/colors.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/colors.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;color name=&quot;purple_500&quot;&gt;#6200EE&lt;/color&gt;&#10;    &lt;color name=&quot;purple_700&quot;&gt;#3700B3&lt;/color&gt;&#10;    &lt;color name=&quot;teal_200&quot;&gt;#03DAC5&lt;/color&gt;&#10;    &lt;color name=&quot;teal_700&quot;&gt;#018786&lt;/color&gt;&#10;    &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;&#10;    &lt;color name=&quot;colorPrimary&quot;&gt;#6200EE&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnPrimary&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;colorSecondary&quot;&gt;#03DAC6&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnSecondary&quot;&gt;#000000&lt;/color&gt;&#10;    &lt;color name=&quot;colorBackground&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnBackground&quot;&gt;#000000&lt;/color&gt;&#10;    &lt;color name=&quot;colorSurface&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnSurface&quot;&gt;#000000&lt;/color&gt;&#10;&lt;/resources&gt;&#10;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;color name=&quot;purple_500&quot;&gt;#6200EE&lt;/color&gt;&#10;    &lt;color name=&quot;purple_700&quot;&gt;#3700B3&lt;/color&gt;&#10;    &lt;color name=&quot;teal_200&quot;&gt;#03DAC5&lt;/color&gt;&#10;    &lt;color name=&quot;teal_700&quot;&gt;#018786&lt;/color&gt;&#10;    &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;&#10;    &lt;color name=&quot;colorPrimary&quot;&gt;#6200EE&lt;/color&gt;&#10;    &lt;color name=&quot;colorPrimaryVariant&quot;&gt;#3700B3&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnPrimary&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;colorSecondary&quot;&gt;#03DAC6&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnSecondary&quot;&gt;#000000&lt;/color&gt;&#10;    &lt;color name=&quot;colorBackground&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnBackground&quot;&gt;#000000&lt;/color&gt;&#10;    &lt;color name=&quot;colorSurface&quot;&gt;#FFFFFF&lt;/color&gt;&#10;    &lt;color name=&quot;colorOnSurface&quot;&gt;#000000&lt;/color&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/styles.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/styles.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt;&#10;        &lt;!-- Customize your theme here. --&gt;&#10;        &lt;item name=&quot;colorPrimary&quot;&gt;@color/purple_500&lt;/item&gt;&#10;        &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/purple_700&lt;/item&gt;&#10;        &lt;item name=&quot;colorOnPrimary&quot;&gt;@color/white&lt;/item&gt;&#10;        &lt;item name=&quot;colorSecondary&quot;&gt;@color/teal_200&lt;/item&gt;&#10;        &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/teal_700&lt;/item&gt;&#10;        &lt;item name=&quot;colorOnSecondary&quot;&gt;@color/black&lt;/item&gt;&#10;        &lt;item name=&quot;android:statusBarColor&quot;&gt;?attr/colorPrimaryVariant&lt;/item&gt;&#10;        &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;&#10;        &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&#10;    &lt;/style&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>