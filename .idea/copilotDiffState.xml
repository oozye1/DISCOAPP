<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoEffect.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoEffect.kt" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.graphics.Color&#10;&#10;/**&#10; * Represents a disco lighting effect configuration.&#10; */&#10;data class DiscoEffect(&#10;    val colors: List&lt;Int&gt; = listOf(Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN),&#10;    val strobe: Boolean = false,&#10;    val fade: Boolean = false,&#10;    val duration: Long = 500L // duration in milliseconds for each color&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoFragment.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AdapterView&#10;import android.widget.ArrayAdapter&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentDiscoBinding&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that hosts the disco lighting experience. A [Spinner] allows the user to select&#10; * from a collection of generated [DiscoEffect]s. The selected effect is applied to the&#10; * [DiscoView] filling the remaining space. Effects are built algorithmically and vary in&#10; * palette, speed, fade transitions and strobing.&#10; */&#10;class DiscoFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDiscoBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private val effects by lazy { EffectRepository.createDiscoEffects(50) }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentDiscoBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Populate the spinner with effect names.&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, effectNames)&#10;        binding.spinnerDiscoEffects.adapter = adapter&#10;        // When the user selects an effect apply it to the DiscoView.&#10;        binding.spinnerDiscoEffects.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {&#10;                val effect = effects[position]&#10;                binding.discoView.setEffect(effect)&#10;            }&#10;            override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {&#10;                // No op.&#10;            }&#10;        }&#10;        // Initially apply the first effect.&#10;        if (effects.isNotEmpty()) {&#10;            binding.discoView.setEffect(effects[0])&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = DiscoFragment()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AdapterView&#10;import android.widget.ArrayAdapter&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentDiscoBinding&#10;import com.example.discoapp.model.DiscoEffect&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that hosts the disco lighting experience. A [Spinner] allows the user to select&#10; * from a collection of generated [DiscoEffect]s. The selected effect is applied to the&#10; * [DiscoView] filling the remaining space. Effects are built algorithmically and vary in&#10; * palette, speed, fade transitions and strobing.&#10; */&#10;class DiscoFragment : Fragment() {&#10;&#10;    private var _binding: FragmentDiscoBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private val effects by lazy { EffectRepository.createDiscoEffects(50) }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentDiscoBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Populate the spinner with effect names.&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, effectNames)&#10;        binding.spinnerDiscoEffects.adapter = adapter&#10;        // When the user selects an effect apply it to the DiscoView.&#10;        binding.spinnerDiscoEffects.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {&#10;                val effect = effects[position]&#10;                binding.discoView.setEffect(effect)&#10;            }&#10;            override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {&#10;                // No op.&#10;            }&#10;        }&#10;        // Initially apply the first effect.&#10;        if (effects.isNotEmpty()) {&#10;            binding.discoView.setEffect(effects[0])&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = DiscoFragment()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/DiscoView.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.animation.ArgbEvaluator&#10;import android.animation.ValueAnimator&#10;import android.content.Context&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import androidx.core.animation.doOnEnd&#10;import com.example.discoapp.model.DiscoEffect&#10;&#10;/**&#10; * A custom view responsible for rendering a fullâ€‘screen disco lighting effect. The view cycles&#10; * through a list of colors defined in [DiscoEffect.colors] at a specified interval. When&#10; * [DiscoEffect.fade] is enabled, the transition between colors is animated using an&#10; * [ArgbEvaluator]; otherwise colors switch abruptly. If strobing is enabled, black frames&#10; * are inserted between colors to emulate a traditional strobe light.&#10; */&#10;class DiscoView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    /** A handler tied to the main thread for scheduling color changes when not animating. */&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var effect: DiscoEffect? = null&#10;    private var currentColorIndex: Int = 0&#10;    private var animator: ValueAnimator? = null&#10;    private var currentBackgroundColor: Int = Color.BLACK&#10;&#10;    /** Set a new disco lighting effect. This restarts the color cycle from the beginning. */&#10;    fun setEffect(effect: DiscoEffect) {&#10;        // Cancel any running animation or delayed callbacks.&#10;        animator?.cancel()&#10;        handler.removeCallbacksAndMessages(null)&#10;        // Apply the effect.&#10;        this.effect = effect&#10;        currentColorIndex = 0&#10;        // Kick off the first frame.&#10;        startNext()&#10;    }&#10;&#10;    /** Advance to the next color in the effect list, animating if necessary. */&#10;    private fun startNext() {&#10;        val eff = effect ?: return&#10;        var colors = eff.colors&#10;        // If strobe is enabled, interleave black frames between colors for a strobing effect.&#10;        if (eff.strobe) {&#10;            val strobeList = mutableListOf&lt;Int&gt;()&#10;            for (c in colors) {&#10;                strobeList.add(c)&#10;                strobeList.add(android.graphics.Color.BLACK)&#10;            }&#10;            colors = strobeList.toIntArray()&#10;        }&#10;        if (colors.isEmpty()) return&#10;        val nextColor = colors[currentColorIndex]&#10;        if (eff.fade) {&#10;            animator = android.animation.ValueAnimator.ofObject(android.animation.ArgbEvaluator(), currentBackgroundColor, nextColor).apply {&#10;                duration = eff.duration&#10;                addUpdateListener { animation -&gt;&#10;                    val color = animation.animatedValue as Int&#10;                    setBackgroundColor(color)&#10;                    currentBackgroundColor = color&#10;                }&#10;                androidx.core.animation.doOnEnd {&#10;                    currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                    startNext()&#10;                }&#10;                start()&#10;            }&#10;        } else {&#10;            setBackgroundColor(nextColor)&#10;            currentBackgroundColor = nextColor&#10;            handler.postDelayed({&#10;                currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                startNext()&#10;            }, eff.duration)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.animation.ArgbEvaluator&#10;import android.animation.ValueAnimator&#10;import android.content.Context&#10;import android.graphics.Color&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import androidx.core.animation.doOnEnd&#10;import com.example.discoapp.model.DiscoEffect&#10;&#10;/**&#10; * A custom view responsible for rendering a fullâ€‘screen disco lighting effect. The view cycles&#10; * through a list of colors defined in [DiscoEffect.colors] at a specified interval. When&#10; * [DiscoEffect.fade] is enabled, the transition between colors is animated using an&#10; * [ArgbEvaluator]; otherwise colors switch abruptly. If strobing is enabled, black frames&#10; * are inserted between colors to emulate a traditional strobe light.&#10; */&#10;class DiscoView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    /** A handler tied to the main thread for scheduling color changes when not animating. */&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var effect: DiscoEffect? = null&#10;    private var currentColorIndex: Int = 0&#10;    private var animator: ValueAnimator? = null&#10;    private var currentBackgroundColor: Int = Color.BLACK&#10;&#10;    /** Set a new disco lighting effect. This restarts the color cycle from the beginning. */&#10;    fun setEffect(effect: DiscoEffect) {&#10;        // Cancel any running animation or delayed callbacks.&#10;        animator?.cancel()&#10;        handler.removeCallbacksAndMessages(null)&#10;        // Apply the effect.&#10;        this.effect = effect&#10;        currentColorIndex = 0&#10;        // Kick off the first frame.&#10;        startNext()&#10;    }&#10;&#10;    /** Advance to the next color in the effect list, animating if necessary. */&#10;    private fun startNext() {&#10;        val eff = effect ?: return&#10;        var colors = eff.colors&#10;        // If strobe is enabled, interleave black frames between colors for a strobing effect.&#10;        if (eff.strobe) {&#10;            val strobeList = mutableListOf&lt;Int&gt;()&#10;            for (c in colors) {&#10;                strobeList.add(c)&#10;                strobeList.add(android.graphics.Color.BLACK)&#10;            }&#10;            colors = strobeList.toIntArray()&#10;        }&#10;        if (colors.isEmpty()) return&#10;        val nextColor = colors[currentColorIndex]&#10;        if (eff.fade) {&#10;            animator = android.animation.ValueAnimator.ofObject(android.animation.ArgbEvaluator(), currentBackgroundColor, nextColor).apply {&#10;                duration = eff.duration&#10;                addUpdateListener { animation -&gt;&#10;                    val color = animation.animatedValue as Int&#10;                    setBackgroundColor(color)&#10;                    currentBackgroundColor = color&#10;                }&#10;                doOnEnd {&#10;                    currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                    startNext()&#10;                }&#10;                start()&#10;            }&#10;        } else {&#10;            setBackgroundColor(nextColor)&#10;            currentBackgroundColor = nextColor&#10;            handler.postDelayed({&#10;                currentColorIndex = (currentColorIndex + 1) % colors.size&#10;                startNext()&#10;            }, eff.duration)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerFragment.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AdapterView&#10;import android.widget.ArrayAdapter&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentVisualizerBinding&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that renders audio responsive visuals. It requests the RECORD_AUDIO permission on&#10; * demand and, once granted, allows the user to choose between a variety of visualizer effects.&#10; */&#10;class VisualizerFragment : Fragment() {&#10;&#10;    private var _binding: FragmentVisualizerBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val effects by lazy { EffectRepository.createVisualizerEffects(51) }&#10;    // Launcher for requesting audio recording permission.&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted; apply the selected effect.&#10;            applyEffect(binding.spinnerVisualizerEffects.selectedItemPosition)&#10;        } else {&#10;            // Permission denied; inform the user.&#10;            binding.visualizerView.visibility = View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentVisualizerBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, effectNames)&#10;        binding.spinnerVisualizerEffects.adapter = adapter&#10;        binding.spinnerVisualizerEffects.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {&#10;                applyEffect(position)&#10;            }&#10;            override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {}&#10;        }&#10;        // Initially hide the view until permission is granted.&#10;        binding.visualizerView.visibility = View.INVISIBLE&#10;    }&#10;&#10;    /**&#10;     * Applies the visualizer effect at the given index after ensuring the RECORD_AUDIO permission&#10;     * has been granted. If the permission is not available, it requests it.&#10;     */&#10;    private fun applyEffect(index: Int) {&#10;        val context = context ?: return&#10;        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {&#10;            // Permission has already been granted. Show the visualizer and apply the effect.&#10;            binding.visualizerView.visibility = View.VISIBLE&#10;            binding.visualizerView.setEffect(effects[index])&#10;        } else {&#10;            // Request permission. The result is handled in requestPermissionLauncher.&#10;            requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = VisualizerFragment()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AdapterView&#10;import android.widget.ArrayAdapter&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import com.example.discoapp.databinding.FragmentVisualizerBinding&#10;import com.example.discoapp.model.EffectRepository&#10;&#10;/**&#10; * Fragment that renders audio responsive visuals. It requests the RECORD_AUDIO permission on&#10; * demand and, once granted, allows the user to choose between a variety of visualizer effects.&#10; */&#10;class VisualizerFragment : Fragment() {&#10;&#10;    private var _binding: FragmentVisualizerBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val effects by lazy { EffectRepository.createVisualizerEffects(51) }&#10;    // Launcher for requesting audio recording permission.&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted; apply the selected effect.&#10;            applyEffect(binding.spinnerVisualizerEffects.selectedItemPosition)&#10;        } else {&#10;            // Permission denied; inform the user.&#10;            binding.visualizerView.visibility = View.INVISIBLE&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentVisualizerBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        val effectNames = effects.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, effectNames)&#10;        binding.spinnerVisualizerEffects.adapter = adapter&#10;        binding.spinnerVisualizerEffects.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {&#10;                applyEffect(position)&#10;            }&#10;            override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {}&#10;        }&#10;        // Initially hide the view until permission is granted.&#10;        binding.visualizerView.visibility = View.INVISIBLE&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        applyEffect(binding.spinnerVisualizerEffects.selectedItemPosition)&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        binding.visualizerView.stop()&#10;    }&#10;&#10;    /**&#10;     * Applies the visualizer effect at the given index after ensuring the RECORD_AUDIO permission&#10;     * has been granted. If the permission is not available, it requests it.&#10;     */&#10;    private fun applyEffect(index: Int) {&#10;        val context = context ?: return&#10;        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {&#10;            // Permission has already been granted. Show the visualizer and apply the effect.&#10;            binding.visualizerView.visibility = View.VISIBLE&#10;            binding.visualizerView.setEffect(effects[index])&#10;            binding.visualizerView.start()&#10;        } else {&#10;            // Request permission. The result is handled in requestPermissionLauncher.&#10;            requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    companion object {&#10;        fun newInstance() = VisualizerFragment()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/VisualizerView.kt" />
              <option name="originalContent" value="package com.example.discoapp&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.graphics.Canvas&#10;import android.graphics.LinearGradient&#10;import android.graphics.Paint&#10;import android.graphics.Path&#10;import android.graphics.Shader&#10;import android.media.AudioFormat&#10;import android.media.AudioRecord&#10;import android.media.MediaRecorder&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import com.example.discoapp.model.VisualizerEffect&#10;import com.example.discoapp.model.VisualizerShape&#10;import kotlin.math.abs&#10;import kotlin.math.cos&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;/**&#10; * A custom view that visualizes audio data captured from the device's microphone. The view&#10; * supports three distinct shapesâ€”bars, radial spokes and a waveformâ€”whose appearance and&#10; * behaviour are controlled through instances of [VisualizerEffect].&#10; *&#10; * The view manages an underlying [AudioRecord] instance to capture raw audio data. When a new&#10; * effect is set via [setEffect], the view resets its renderer and applies the new colours,&#10; * bar count and amplitude multiplier. When the view is detached from the window it releases&#10; * the audio resources to conserve power.&#10; */&#10;class VisualizerView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    private var audioRecord: AudioRecord? = null&#10;    private var waveform: ByteArray = ByteArray(0)&#10;    private var effect: VisualizerEffect? = null&#10;    private val paint = Paint().apply {&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    private var gradient: LinearGradient? = null&#10;    private var isCapturing = false&#10;&#10;    /**&#10;     * Assign an effect to this view and initialize audio capture if necessary. This method&#10;     * should be called after the RECORD_AUDIO permission has been granted. Setting a new effect&#10;     * replaces any existing effect and resets the colour gradient.&#10;     */&#10;    fun setEffect(effect: VisualizerEffect) {&#10;        this.effect = effect&#10;        gradient = null&#10;        invalidate()&#10;    }&#10;&#10;    /**&#10;     * Set up and start the [AudioRecord] instance to capture audio from the microphone. Audio&#10;     * data is read in a background thread to avoid blocking the UI.&#10;     */&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun start() {&#10;        if (isCapturing) return&#10;        try {&#10;            val sampleRate = 44100&#10;            val channelConfig = AudioFormat.CHANNEL_IN_MONO&#10;            val audioFormat = AudioFormat.ENCODING_PCM_8BIT&#10;            val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat).coerceAtLeast(1024)&#10;&#10;            audioRecord = AudioRecord(&#10;                MediaRecorder.AudioSource.MIC,&#10;                sampleRate,&#10;                channelConfig,&#10;                audioFormat,&#10;                bufferSize&#10;            )&#10;&#10;            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {&#10;                audioRecord = null&#10;                return&#10;            }&#10;&#10;            waveform = ByteArray(bufferSize)&#10;            audioRecord?.startRecording()&#10;&#10;            isCapturing = true&#10;            Thread {&#10;                while (isCapturing) {&#10;                    audioRecord?.read(waveform, 0, waveform.size)&#10;                    postInvalidate()&#10;                }&#10;                audioRecord?.stop()&#10;                audioRecord?.release()&#10;                audioRecord = null&#10;            }.start()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    fun stop() {&#10;        isCapturing = false&#10;    }&#10;&#10;    override fun onDetachedFromWindow() {&#10;        super.onDetachedFromWindow()&#10;        stop()&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        rebuildGradient()&#10;    }&#10;&#10;    /** Recreate a linear gradient across the width of the view using the current effect colours. */&#10;    private fun rebuildGradient() {&#10;        val eff = effect ?: return&#10;        if (eff.colors.size &gt; 1) {&#10;            val positions = FloatArray(eff.colors.size) { i -&gt; i.toFloat() / (eff.colors.size - 1) }&#10;            gradient = LinearGradient(&#10;                0f, 0f, width.toFloat(), 0f,&#10;                eff.colors, positions, Shader.TileMode.CLAMP&#10;            )&#10;        } else {&#10;            gradient = null&#10;        }&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        val eff = effect ?: return&#10;        if (waveform.isEmpty() || !isCapturing) return&#10;        when (eff.shape) {&#10;            VisualizerShape.BARS -&gt; drawBars(canvas, eff)&#10;            VisualizerShape.RADIAL -&gt; drawRadial(canvas, eff)&#10;            VisualizerShape.WAVE -&gt; drawWave(canvas, eff)&#10;        }&#10;    }&#10;&#10;    /** Draws a vertical bar graph where each bar height corresponds to the amplitude of a sample. */&#10;    private fun drawBars(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        if (barCount &lt;= 0) return&#10;        val barWidth = width.toFloat() / barCount&#10;        val centerY = height.toFloat()&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * centerY * eff.amplitudeMultiplier&#10;            val left = i * barWidth&#10;            val right = left + barWidth * 0.8f&#10;            val top = centerY - amplitude&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawRect(left, top, right, centerY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws radial spokes emanating from the center of the view based on amplitude. */&#10;    private fun drawRadial(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        val centerX = width / 2f&#10;        val centerY = height / 2f&#10;        val maxRadius = min(width, height) / 2f&#10;        paint.strokeWidth = 4f&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * maxRadius * eff.amplitudeMultiplier&#10;            val angle = (2.0 * Math.PI * i / barCount).toFloat()&#10;            val endX = centerX + amplitude * cos(angle)&#10;            val endY = centerY + amplitude * sin(angle)&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawLine(centerX, centerY, endX, endY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws a continuous waveform across the width of the view. */&#10;    private fun drawWave(canvas: Canvas, eff: VisualizerEffect) {&#10;        val dataLength = waveform.size&#10;        if (dataLength == 0) return&#10;        val path = Path()&#10;        val halfHeight = height / 2f&#10;        val step = width.toFloat() / dataLength&#10;        for (i in 0 until dataLength) {&#10;            val value = waveform[i].toInt() and 0xFF&#10;            val amplitude = (value - 128) / 128f * halfHeight * eff.amplitudeMultiplier&#10;            val x = i * step&#10;            val y = halfHeight + amplitude&#10;            if (i == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;        paint.strokeWidth = 4f&#10;        paint.style = Paint.Style.STROKE&#10;        if (gradient != null) {&#10;            paint.shader = gradient&#10;        } else {&#10;            paint.color = eff.colors.firstOrNull() ?: 0xFFFFFFFF.toInt()&#10;            paint.shader = null&#10;        }&#10;        canvas.drawPath(path, paint)&#10;        // Reset style for next draw call.&#10;        paint.style = Paint.Style.FILL&#10;        paint.shader = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.graphics.Canvas&#10;import android.graphics.LinearGradient&#10;import android.graphics.Paint&#10;import android.graphics.Path&#10;import android.graphics.Shader&#10;import android.media.AudioFormat&#10;import android.media.AudioRecord&#10;import android.media.MediaRecorder&#10;import android.util.AttributeSet&#10;import android.view.View&#10;import com.example.discoapp.model.VisualizerEffect&#10;import com.example.discoapp.model.VisualizerShape&#10;import kotlin.math.abs&#10;import kotlin.math.cos&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;/**&#10; * A custom view that visualizes audio data captured from the device's microphone. The view&#10; * supports three distinct shapesâ€”bars, radial spokes and a waveformâ€”whose appearance and&#10; * behaviour are controlled through instances of [VisualizerEffect].&#10; *&#10; * The view manages an underlying [AudioRecord] instance to capture raw audio data. When a new&#10; * effect is set via [setEffect], the view resets its renderer and applies the new colours,&#10; * bar count and amplitude multiplier. When the view is detached from the window it releases&#10; * the audio resources to conserve power.&#10; */&#10;class VisualizerView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    private var audioRecord: AudioRecord? = null&#10;    private var waveform: ByteArray = ByteArray(0)&#10;    private var effect: VisualizerEffect? = null&#10;    private val paint = Paint().apply {&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    private var gradient: LinearGradient? = null&#10;    private var captureThread: Thread? = null&#10;    private var isCapturing = false&#10;&#10;    /**&#10;     * Assign an effect to this view and initialize audio capture if necessary. This method&#10;     * should be called after the RECORD_AUDIO permission has been granted. Setting a new effect&#10;     * replaces any existing effect and resets the colour gradient.&#10;     */&#10;    fun setEffect(effect: VisualizerEffect) {&#10;        this.effect = effect&#10;        gradient = null&#10;        invalidate()&#10;    }&#10;&#10;    /**&#10;     * Set up and start the [AudioRecord] instance to capture audio from the microphone. Audio&#10;     * data is read in a background thread to avoid blocking the UI.&#10;     */&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun start() {&#10;        if (isCapturing) return&#10;        try {&#10;            val sampleRate = 44100&#10;            val channelConfig = AudioFormat.CHANNEL_IN_MONO&#10;            val audioFormat = AudioFormat.ENCODING_PCM_8BIT&#10;            val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat).coerceAtLeast(1024)&#10;&#10;            audioRecord = AudioRecord(&#10;                MediaRecorder.AudioSource.MIC,&#10;                sampleRate,&#10;                channelConfig,&#10;                audioFormat,&#10;                bufferSize&#10;            )&#10;&#10;            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {&#10;                audioRecord = null&#10;                return&#10;            }&#10;&#10;            waveform = ByteArray(bufferSize)&#10;            audioRecord?.startRecording()&#10;&#10;            isCapturing = true&#10;            captureThread = Thread {&#10;                while (isCapturing) {&#10;                    audioRecord?.read(waveform, 0, waveform.size)&#10;                    postInvalidate()&#10;                }&#10;            }&#10;            captureThread?.start()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    fun stop() {&#10;        if (!isCapturing) return&#10;        isCapturing = false&#10;        try {&#10;            captureThread?.join(100)&#10;        } catch (e: InterruptedException) {&#10;            Thread.currentThread().interrupt()&#10;        }&#10;        captureThread = null&#10;        if (audioRecord?.recordingState == AudioRecord.RECORDSTATE_RECORDING) {&#10;            audioRecord?.stop()&#10;        }&#10;        audioRecord?.release()&#10;        audioRecord = null&#10;    }&#10;&#10;    override fun onDetachedFromWindow() {&#10;        super.onDetachedFromWindow()&#10;        stop()&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        rebuildGradient()&#10;    }&#10;&#10;    /** Recreate a linear gradient across the width of the view using the current effect colours. */&#10;    private fun rebuildGradient() {&#10;        val eff = effect ?: return&#10;        if (eff.colors.size &gt; 1) {&#10;            val positions = FloatArray(eff.colors.size) { i -&gt; i.toFloat() / (eff.colors.size - 1) }&#10;            gradient = LinearGradient(&#10;                0f, 0f, width.toFloat(), 0f,&#10;                eff.colors, positions, Shader.TileMode.CLAMP&#10;            )&#10;        } else {&#10;            gradient = null&#10;        }&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        val eff = effect ?: return&#10;        if (waveform.isEmpty() || !isCapturing) return&#10;        when (eff.shape) {&#10;            VisualizerShape.BARS -&gt; drawBars(canvas, eff)&#10;            VisualizerShape.RADIAL -&gt; drawRadial(canvas, eff)&#10;            VisualizerShape.WAVE -&gt; drawWave(canvas, eff)&#10;        }&#10;    }&#10;&#10;    /** Draws a vertical bar graph where each bar height corresponds to the amplitude of a sample. */&#10;    private fun drawBars(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        if (barCount &lt;= 0) return&#10;        val barWidth = width.toFloat() / barCount&#10;        val centerY = height.toFloat()&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * centerY * eff.amplitudeMultiplier&#10;            val left = i * barWidth&#10;            val right = left + barWidth * 0.8f&#10;            val top = centerY - amplitude&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawRect(left, top, right, centerY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws radial spokes emanating from the center of the view based on amplitude. */&#10;    private fun drawRadial(canvas: Canvas, eff: VisualizerEffect) {&#10;        val barCount = eff.barCount&#10;        val centerX = width / 2f&#10;        val centerY = height / 2f&#10;        val maxRadius = min(width, height) / 2f&#10;        paint.strokeWidth = 4f&#10;        for (i in 0 until barCount) {&#10;            val index = (waveform.size * i) / barCount&#10;            val value = waveform[index].toInt() and 0xFF&#10;            val amplitude = abs(value - 128) / 128f * maxRadius * eff.amplitudeMultiplier&#10;            val angle = (2.0 * Math.PI * i / barCount).toFloat()&#10;            val endX = centerX + amplitude * cos(angle)&#10;            val endY = centerY + amplitude * sin(angle)&#10;            paint.color = eff.colors[i % eff.colors.size]&#10;            canvas.drawLine(centerX, centerY, endX, endY, paint)&#10;        }&#10;    }&#10;&#10;    /** Draws a continuous waveform across the width of the view. */&#10;    private fun drawWave(canvas: Canvas, eff: VisualizerEffect) {&#10;        val dataLength = waveform.size&#10;        if (dataLength == 0) return&#10;        val path = Path()&#10;        val halfHeight = height / 2f&#10;        val step = width.toFloat() / dataLength&#10;        for (i in 0 until dataLength) {&#10;            val value = waveform[i].toInt() and 0xFF&#10;            val amplitude = (value - 128) / 128f * halfHeight * eff.amplitudeMultiplier&#10;            val x = i * step&#10;            val y = halfHeight + amplitude&#10;            if (i == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;        paint.strokeWidth = 4f&#10;        paint.style = Paint.Style.STROKE&#10;        if (gradient != null) {&#10;            paint.shader = gradient&#10;        } else {&#10;            paint.color = eff.colors.firstOrNull() ?: 0xFFFFFFFF.toInt()&#10;            paint.shader = null&#10;        }&#10;        canvas.drawPath(path, paint)&#10;        // Reset style for next draw call.&#10;        paint.style = Paint.Style.FILL&#10;        paint.shader = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/DiscoEffect.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/DiscoEffect.kt" />
              <option name="originalContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;&#10;/**&#10; * Represents a disco lighting effect configuration.&#10; */&#10;data class DiscoEffect(&#10;    val name: String = &quot;Default&quot;,&#10;    val colors: List&lt;Int&gt; = listOf(Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN),&#10;    val duration: Long = 500L, // duration in milliseconds for each color&#10;    val fade: Boolean = false,&#10;    val strobe: Boolean = false&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;&#10;/**&#10; * Represents a disco lighting effect configuration.&#10; */&#10;data class DiscoEffect(&#10;    val name: String = &quot;Default&quot;,&#10;    val colors: List&lt;Int&gt; = listOf(Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN),&#10;    val duration: Long = 500L, // duration in milliseconds for each color&#10;    val fade: Boolean = false,&#10;    val strobe: Boolean = false&#10;)&#10;&#10;// Duplicate DiscoEffect removed. Use the one in EffectModels.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/EffectRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/discoapp/model/EffectRepository.kt" />
              <option name="originalContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;import java.util.Random&#10;&#10;/**&#10; * Factory methods for generating a collection of disco and visualizer effects. To keep the&#10; * application lightweight and to avoid handâ€‘crafting dozens of variations, this repository&#10; * algorithmically derives different combinations of color palettes, animation speeds, shapes&#10; * and amplitude multipliers based on the index of the requested effect. This makes it easy&#10; * to provide a large number of unique visual experiences without repeating code.&#10; */&#10;object EffectRepository {&#10;&#10;    /** A set of base color palettes used to construct more complex effects. */&#10;    private val palettes: List&lt;IntArray&gt; = listOf(&#10;        intArrayOf(Color.parseColor(&quot;#ff1744&quot;), Color.parseColor(&quot;#d500f9&quot;), Color.parseColor(&quot;#2979ff&quot;), Color.parseColor(&quot;#00e5ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff6f00&quot;), Color.parseColor(&quot;#fdd835&quot;), Color.parseColor(&quot;#64dd17&quot;), Color.parseColor(&quot;#1de9b6&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ab47bc&quot;), Color.parseColor(&quot;#ef5350&quot;), Color.parseColor(&quot;#ffa726&quot;), Color.parseColor(&quot;#66bb6a&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#00b0ff&quot;), Color.parseColor(&quot;#651fff&quot;), Color.parseColor(&quot;#c51162&quot;), Color.parseColor(&quot;#ff4081&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#4caf50&quot;), Color.parseColor(&quot;#009688&quot;), Color.parseColor(&quot;#00bcd4&quot;), Color.parseColor(&quot;#3f51b5&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff8a80&quot;), Color.parseColor(&quot;#ff80ab&quot;), Color.parseColor(&quot;#ea80fc&quot;), Color.parseColor(&quot;#b388ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ffd180&quot;), Color.parseColor(&quot;#ffe57f&quot;), Color.parseColor(&quot;#dcedc8&quot;), Color.parseColor(&quot;#b2ebf2&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#81d4fa&quot;), Color.parseColor(&quot;#80cbc4&quot;), Color.parseColor(&quot;#c5e1a5&quot;), Color.parseColor(&quot;#f8bbd0&quot;))&#10;    )&#10;&#10;    /**&#10;     * Create a list of disco effects. Each effect's parameters are derived from its index&#10;     * to produce a variety of rhythms, fades and strobing behaviours. The number of effects&#10;     * generated is determined by [count].&#10;     */&#10;    fun createDiscoEffects(count: Int): List&lt;DiscoEffect&gt; {&#10;        val effects = mutableListOf&lt;DiscoEffect&gt;()&#10;        val random = Random(System.currentTimeMillis())&#10;        for (i in 0 until count) {&#10;            val name = &quot;Effect ${i + 1}&quot;&#10;            val duration = random.nextLong(250, 1000)&#10;            val fade = random.nextBoolean()&#10;            val strobe = random.nextBoolean()&#10;            val palette = createPalette(random)&#10;            effects += DiscoEffect(name, palette, duration, fade, strobe)&#10;        }&#10;        return effects&#10;    }&#10;&#10;    /**&#10;     * Create a list of visualizer effects. Each effect's attributes are derived from its index&#10;     * to vary bar counts, shapes, colors and amplitude scaling. The number of effects generated&#10;     * is determined by [count].&#10;     */&#10;    fun createVisualizerEffects(count: Int): List&lt;VisualizerEffect&gt; {&#10;        val effects = mutableListOf&lt;VisualizerEffect&gt;()&#10;        for (i in 0 until count) {&#10;            val palette = palettes[(i + 2) % palettes.size]&#10;            // Determine bar count: 16, 32, 48, 64 depending on index.&#10;            val barCount = when (i % 4) {&#10;                0 -&gt; 16&#10;                1 -&gt; 32&#10;                2 -&gt; 48&#10;                else -&gt; 64&#10;            }&#10;            // Alternate shape between bars, radial and wave.&#10;            val shape = when (i % 3) {&#10;                0 -&gt; VisualizerShape.BARS&#10;                1 -&gt; VisualizerShape.RADIAL&#10;                else -&gt; VisualizerShape.WAVE&#10;            }&#10;            // Determine amplitude multiplier between 2.0f and 5.0f.&#10;            val amplitudeMultiplier = 2.0f + (i % 4) * 0.75f&#10;            val name = &quot;Visualizer #${i + 1}&quot;&#10;            effects += VisualizerEffect(name, barCount, shape, palette, amplitudeMultiplier)&#10;        }&#10;        return effects&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.discoapp.model&#10;&#10;import android.graphics.Color&#10;import java.util.Random&#10;&#10;/**&#10; * Factory methods for generating a collection of disco and visualizer effects. To keep the&#10; * application lightweight and to avoid handâ€‘crafting dozens of variations, this repository&#10; * algorithmically derives different combinations of color palettes, animation speeds, shapes&#10; * and amplitude multipliers based on the index of the requested effect. This makes it easy&#10; * to provide a large number of unique visual experiences without repeating code.&#10; */&#10;object EffectRepository {&#10;&#10;    /** A set of base color palettes used to construct more complex effects. */&#10;    private val palettes: List&lt;IntArray&gt; = listOf(&#10;        intArrayOf(Color.parseColor(&quot;#ff1744&quot;), Color.parseColor(&quot;#d500f9&quot;), Color.parseColor(&quot;#2979ff&quot;), Color.parseColor(&quot;#00e5ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff6f00&quot;), Color.parseColor(&quot;#fdd835&quot;), Color.parseColor(&quot;#64dd17&quot;), Color.parseColor(&quot;#1de9b6&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ab47bc&quot;), Color.parseColor(&quot;#ef5350&quot;), Color.parseColor(&quot;#ffa726&quot;), Color.parseColor(&quot;#66bb6a&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#00b0ff&quot;), Color.parseColor(&quot;#651fff&quot;), Color.parseColor(&quot;#c51162&quot;), Color.parseColor(&quot;#ff4081&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#4caf50&quot;), Color.parseColor(&quot;#009688&quot;), Color.parseColor(&quot;#00bcd4&quot;), Color.parseColor(&quot;#3f51b5&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ff8a80&quot;), Color.parseColor(&quot;#ff80ab&quot;), Color.parseColor(&quot;#ea80fc&quot;), Color.parseColor(&quot;#b388ff&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#ffd180&quot;), Color.parseColor(&quot;#ffe57f&quot;), Color.parseColor(&quot;#dcedc8&quot;), Color.parseColor(&quot;#b2ebf2&quot;)),&#10;        intArrayOf(Color.parseColor(&quot;#81d4fa&quot;), Color.parseColor(&quot;#80cbc4&quot;), Color.parseColor(&quot;#c5e1a5&quot;), Color.parseColor(&quot;#f8bbd0&quot;))&#10;    )&#10;&#10;    /**&#10;     * Create a list of disco effects. Each effect's parameters are derived from its index&#10;     * to produce a variety of rhythms, fades and strobing behaviours. The number of effects&#10;     * generated is determined by [count].&#10;     */&#10;    fun createDiscoEffects(count: Int): List&lt;DiscoEffect&gt; {&#10;        val effects = mutableListOf&lt;DiscoEffect&gt;()&#10;        val random = Random(System.currentTimeMillis())&#10;        for (i in 0 until count) {&#10;            val name = &quot;Effect ${i + 1}&quot;&#10;            val duration = (250 + random.nextInt(750)).toLong()&#10;            val fade = random.nextBoolean()&#10;            val strobe = random.nextBoolean()&#10;            val palette = createPalette(random)&#10;            effects += DiscoEffect(name, palette, duration, fade, strobe)&#10;        }&#10;        return effects&#10;    }&#10;&#10;    /**&#10;     * Create a list of visualizer effects. Each effect's attributes are derived from its index&#10;     * to vary bar counts, shapes, colors and amplitude scaling. The number of effects generated&#10;     * is determined by [count].&#10;     */&#10;    fun createVisualizerEffects(count: Int): List&lt;VisualizerEffect&gt; {&#10;        val effects = mutableListOf&lt;VisualizerEffect&gt;()&#10;        for (i in 0 until count) {&#10;            val palette = palettes[(i + 2) % palettes.size]&#10;            // Determine bar count: 16, 32, 48, 64 depending on index.&#10;            val barCount = when (i % 4) {&#10;                0 -&gt; 16&#10;                1 -&gt; 32&#10;                2 -&gt; 48&#10;                else -&gt; 64&#10;            }&#10;            // Alternate shape between bars, radial and wave.&#10;            val shape = when (i % 3) {&#10;                0 -&gt; VisualizerShape.BARS&#10;                1 -&gt; VisualizerShape.RADIAL&#10;                else -&gt; VisualizerShape.WAVE&#10;            }&#10;            // Determine amplitude multiplier between 2.0f and 5.0f.&#10;            val amplitudeMultiplier = 2.0f + (i % 4) * 0.75f&#10;            val name = &quot;Visualizer #${i + 1}&quot;&#10;            effects += VisualizerEffect(name, barCount, shape, palette, amplitudeMultiplier)&#10;        }&#10;        return effects&#10;    }&#10;&#10;    private fun createPalette(random: Random): IntArray {&#10;        return palettes[random.nextInt(palettes.size)]&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>